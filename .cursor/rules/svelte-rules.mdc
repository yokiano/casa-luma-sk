---
globs: *.svelte
alwaysApply: false
---
# Svelte 5 example and cheatsheet.

This is an example of a svelte 5 syntax component. 
It tries to demonstrate the most common use cases for the new svelte 5 syntax, tryig to highlihgt the differences between v4 and v5.

this component is a simple counter with a label and a value.

```ts
<script lang="ts">
  import { Component, Snippet } from 'svelte';

  interface Props {
    label: string;
    icon: Component;
    value: number;

    // (optional) children snippet -a snippet used to render all un-named slots of the component. instead of <slot /> in svelte 4.
    children?: Snippet;

    // we can also name the snippet/slots and pass arguments to them.
    displaySnippet?: Snippet<[number]>;
  }

  let {
    label,
    value = $bindable(0), // to make a property bindable, we use the $bindable decorator.
    
    children,
    displaySnippet,

    // Renaming so we can use it as component in the markup.
    icon : Icon,
  }: Props = $props();

  // We can define $state runes for anything that we want to be reactive and/or we want to mutate it later. replaces the "let multiplier = 100" in svelte 4.
  // State of complex objects (array/object) is deeply reactive, and they should be passed using getters/setters if passed by value.
  let multiplier = $state(100);

  // We can also create derived values from state (properties passed to component are automatically state runes )
  const value100x = $derived(value * multiplier);

  let maximumNumber = $state(2000);

  const valueMax = $derived.by(() => {
    if (value100x > maximumNumber) return maximumNumber;
    else return value100x;
  });

  // For tracking on runes (state/derived) we can use $inspect which will print to the console everytime the value updtes. good for troubleshooting.
  $inspect(valueMax);

  // We can also create effects to react to state changes. Any state rune inside the effect will trigger the effect to run. effects also run on component mount.
  // This is used instead of the $: syntax in svelte 4.
  // Effects should be avoided as much as possible, $derived is usually covers most of the use cases.
  $effect(() => {
    if (valueMax > maximumNumber) {
      console.error(
        'valueMax is greater than maximumNumber, unexpected behavior!'
      );
    }
  });
</script>

<!-- Snippets can also be defined in the component to reuse code (instead of creating a new component). -->
{#snippet defaultDisplay()}
  <div class="flex items-center gap-2">
    
    <!-- in svelte 5 we can use any variable that contains a component as long it has uppercase first letter. this replaces <svelte:component this={icon} /> -->
    <Icon />

    <span class="text-primary bg-secondary">{valueMax}</span>
  </div>
{/snippet}

<div>
  <label for="value"
    >{label}
    <input id="value" type="number" bind:value />
  </label>
  <label for="multiplier"
    >Multiplier
    <input id="multiplier" type="number" bind:value={multiplier} />
  </label>
  <label for="maximumNumber"
    >Maximum Number
    <input id="maximumNumber" type="number" bind:value={maximumNumber} />
  </label>

  {#if displaySnippet}
    <!-- this is how we render snippets. -->
    {@render displaySnippet(value)}
  {:else}
    {@render defaultDisplay()}
  {/if}

  {#if children}
    {@render children()}
  {/if}
</div>
```

## Usage Examples

### Default Display
```ts
<Counter label="Counter 1" icon={someIcon} />
```

### Custom Display
```ts
<Counter label="Counter 1" icon={someIcon} >
{#snippet displaySnippet(value: number)}
  <div class="card">
    <span class="text-red-500">{value}</span>
  </div>
{/snippet}
</Counter>
```

### With Children
```ts
<Counter label="Counter 1" icon={someIcon} >
    <span class="text-red-500 text-sm">this counter was built with svelte 5</span>
</Counter>
```
## More things that have changed since svelte 4

- the `<Component let:something>` syntax is working only on non-runes mode. in runes mode the way to pass variables to component children is using the snippet properties.
- the `on:event` syntax is replaced with `onevent`. So on:click becomes onclick. 
- To allow passing html attributes to the component, the props interface should extend `HTMLAttributes<HTMLSomeElement>`. i.e `interface Props extends HTMLAttributes<HTMLInputElement> { ... }`. Then using `...props` will pass all the html attributes to the component.

## Async/Await (Experimental - Svelte 5.36+)

Starting in Svelte 5.36, `await` can be used in three places where it was previously unavailable:

1. **Top level of component's `<script>`**
2. **Inside `$derived(...)` declarations**
3. **Inside markup**

### Enabling Async Support

This is an experimental feature. Enable it in `svelte.config.js`:

```ts
export default {
  compilerOptions: {
    experimental: {
      async: true
    }
  }
};
```

The experimental flag will be removed in Svelte 6.

### Synchronized Updates

When an `await` expression depends on state, UI updates wait for async work to complete, preventing inconsistent states:

```ts
<script>
  let a = $state(1);
  let b = $state(2);

  async function add(a, b) {
    await new Promise((f) => setTimeout(f, 500));
    return a + b;
  }
</script>

<p>{a} + {b} = {await add(a, b)}</p>
```

If you increment `a`, the UI won't show `2 + 2 = 3` — it waits and updates to `2 + 2 = 4` when the promise resolves.

### Concurrency

Independent `await` expressions run in parallel:

```ts
<p>{await one()}</p>
<p>{await two()}</p>
```

Both functions run simultaneously. However, sequential `await` in `<script>` or inside functions behaves like regular async JavaScript.

### Loading States

Use `<svelte:boundary>` with a `pending` snippet for initial loading:

```ts
<svelte:boundary>
  {#snippet pending()}
    <p>Loading...</p>
  {/snippet}
  
  <div>{await getData()}</div>
</svelte:boundary>
```

For subsequent updates, use `$effect.pending()` to detect ongoing async work (useful for validation spinners).

Use `settled()` to get a promise that resolves when updates complete:

```ts
import { tick, settled } from 'svelte';

async function onclick() {
  let updating = true;
  await tick(); // apply state changes immediately
  
  color = 'octarine';
  answer = 42;
  
  await settled(); // wait for all async updates
  updating = false;
}
```

### Error Handling

Errors in `await` expressions bubble to the nearest error boundary.

### Async in $derived

You can use `await` inside `$derived`:

```ts
let a = $derived(await one());
let b = $derived(await two());
```

These run sequentially on first creation but update independently afterward.

⚠️ **Warning**: Expect an `await_waterfall` warning for sequential awaits in derived values.

### Caveats

- This is experimental; details may change between minor versions
- Effects run in slightly different order when `experimental.async` is enabled
- Block effects (`{#if}`, `{#each}`) now run before `$effect.pre` or `beforeUpdate` in the same component

## Common Mistakes and Corrections

### Snippets Location in the file

The snippet definition ({#snippet}{/snippet}) should be located inside the markup, not in the script block. perferably after the script block before the markup.

### Props Typing

❌ Wrong:
```ts
let { data } = $props<Props>() 
```
✅ Correct:
```ts
let {data} : Props = $props()
```

No Need for declaring state in the prop. all props are automatically state runes. I think.
```ts
let { something = $state(0) } : Props = $props()
```

### Derived Values

❌ Wrong (using derived instead of derived.by):
```ts
const some = $derived(() => {
  // something
});
```
✅ Correct:
```ts
const some = $derived.by(() => {
  // something
});
```

### Derived Calculations

❌ Wrong (not assigning the result):
```ts
$derived.by(() => {
  // something
});
```
✅ Correct:
```ts
const some = $derived.by(() => {
  // something
});
```